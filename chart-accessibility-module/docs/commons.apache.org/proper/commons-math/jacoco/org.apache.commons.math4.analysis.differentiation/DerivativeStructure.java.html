<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="https://commons.apache.org/proper/commons-math/jacoco/.resources/report.css" type="text/css"/><link rel="shortcut icon" href="https://commons.apache.org/proper/commons-math/jacoco/.resources/report.gif" type="image/gif"/><title>DerivativeStructure.java</title><link rel="stylesheet" href="https://commons.apache.org/proper/commons-math/jacoco/.resources/prettify.css" type="text/css"/><script type="text/javascript" src="https://commons.apache.org/proper/commons-math/jacoco/.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="https://commons.apache.org/proper/commons-math/jacoco/.sessions.html" class="el_session">Sessions</a></span><a href="https://commons.apache.org/proper/commons-math/jacoco/index.html" class="el_report">Apache Commons Math</a> &gt; <a href="https://commons.apache.org/proper/commons-math/jacoco/org.apache.commons.math4.analysis.differentiation/index.source.html" class="el_package">org.apache.commons.math4.analysis.differentiation</a> &gt; <span class="el_source">DerivativeStructure.java</span></div><h1>DerivativeStructure.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.analysis.differentiation;

import java.io.Serializable;

import org.apache.commons.math4.Field;
import org.apache.commons.math4.FieldElement;
import org.apache.commons.math4.RealFieldElement;
import org.apache.commons.math4.exception.DimensionMismatchException;
import org.apache.commons.math4.exception.MathArithmeticException;
import org.apache.commons.math4.exception.NumberIsTooLargeException;
import org.apache.commons.math4.util.FastMath;
import org.apache.commons.math4.util.MathArrays;
import org.apache.commons.math4.util.MathUtils;

/** Class representing both the value and the differentials of a function.
 * &lt;p&gt;This class is the workhorse of the differentiation package.&lt;/p&gt;
 * &lt;p&gt;This class is an implementation of the extension to Rall's
 * numbers described in Dan Kalman's paper &lt;a
 * href=&quot;http://www1.american.edu/cas/mathstat/People/kalman/pdffiles/mmgautodiff.pdf&quot;&gt;Doubly
 * Recursive Multivariate Automatic Differentiation&lt;/a&gt;, Mathematics Magazine, vol. 75,
 * no. 3, June 2002. Rall's numbers are an extension to the real numbers used
 * throughout mathematical expressions; they hold the derivative together with the
 * value of a function. Dan Kalman's derivative structures hold all partial derivatives
 * up to any specified order, with respect to any number of free parameters. Rall's
 * numbers therefore can be seen as derivative structures for order one derivative and
 * one free parameter, and real numbers can be seen as derivative structures with zero
 * order derivative and no free parameters.&lt;/p&gt;
 * &lt;p&gt;{@link DerivativeStructure} instances can be used directly thanks to
 * the arithmetic operators to the mathematical functions provided as
 * methods by this class (+, -, *, /, %, sin, cos ...).&lt;/p&gt;
 * &lt;p&gt;Implementing complex expressions by hand using these classes is
 * a tedious and error-prone task but has the advantage of having no limitation
 * on the derivation order despite not requiring users to compute the derivatives by
 * themselves. Implementing complex expression can also be done by developing computation
 * code using standard primitive double values and to use {@link
 * UnivariateFunctionDifferentiator differentiators} to create the {@link
 * DerivativeStructure}-based instances. This method is simpler but may be limited in
 * the accuracy and derivation orders and may be computationally intensive (this is
 * typically the case for {@link FiniteDifferencesDifferentiator finite differences
 * differentiator}.&lt;/p&gt;
 * &lt;p&gt;Instances of this class are guaranteed to be immutable.&lt;/p&gt;
 * @see DSCompiler
 * @since 3.1
 */
public class DerivativeStructure implements RealFieldElement&lt;DerivativeStructure&gt;, Serializable {

    /** Serializable UID. */
    private static final long serialVersionUID = 20120730L;

    /** Compiler for the current dimensions. */
    private transient DSCompiler compiler;

    /** Combined array holding all values. */
    private final double[] data;

    /** Build an instance with all values and derivatives set to 0.
     * @param compiler compiler to use for computation
     */
<span class="fc" id="L75">    private DerivativeStructure(final DSCompiler compiler) {</span>
<span class="fc" id="L76">        this.compiler = compiler;</span>
<span class="fc" id="L77">        this.data     = new double[compiler.getSize()];</span>
<span class="fc" id="L78">    }</span>

    /** Build an instance with all values and derivatives set to 0.
     * @param parameters number of free parameters
     * @param order derivation order
     * @throws NumberIsTooLargeException if order is too large
     */
    public DerivativeStructure(final int parameters, final int order)
        throws NumberIsTooLargeException {
<span class="fc" id="L87">        this(DSCompiler.getCompiler(parameters, order));</span>
<span class="fc" id="L88">    }</span>

    /** Build an instance representing a constant value.
     * @param parameters number of free parameters
     * @param order derivation order
     * @param value value of the constant
     * @throws NumberIsTooLargeException if order is too large
     * @see #DerivativeStructure(int, int, int, double)
     */
    public DerivativeStructure(final int parameters, final int order, final double value)
        throws NumberIsTooLargeException {
<span class="fc" id="L99">        this(parameters, order);</span>
<span class="fc" id="L100">        this.data[0] = value;</span>
<span class="fc" id="L101">    }</span>

    /** Build an instance representing a variable.
     * &lt;p&gt;Instances built using this constructor are considered
     * to be the free variables with respect to which differentials
     * are computed. As such, their differential with respect to
     * themselves is +1.&lt;/p&gt;
     * @param parameters number of free parameters
     * @param order derivation order
     * @param index index of the variable (from 0 to {@code parameters - 1})
     * @param value value of the variable
     * @exception NumberIsTooLargeException if {@code index &amp;ge; parameters}.
     * @see #DerivativeStructure(int, int, double)
     */
    public DerivativeStructure(final int parameters, final int order,
                               final int index, final double value)
        throws NumberIsTooLargeException {
<span class="fc" id="L118">        this(parameters, order, value);</span>

<span class="fc bfc" id="L120" title="All 2 branches covered.">        if (index &gt;= parameters) {</span>
<span class="fc" id="L121">            throw new NumberIsTooLargeException(index, parameters, false);</span>
        }

<span class="fc bfc" id="L124" title="All 2 branches covered.">        if (order &gt; 0) {</span>
            // the derivative of the variable with respect to itself is 1.
<span class="fc" id="L126">            data[DSCompiler.getCompiler(index, order).getSize()] = 1.0;</span>
        }

<span class="fc" id="L129">    }</span>

    /** Linear combination constructor.
     * The derivative structure built will be a1 * ds1 + a2 * ds2
     * @param a1 first scale factor
     * @param ds1 first base (unscaled) derivative structure
     * @param a2 second scale factor
     * @param ds2 second base (unscaled) derivative structure
     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent
     */
    public DerivativeStructure(final double a1, final DerivativeStructure ds1,
                               final double a2, final DerivativeStructure ds2)
        throws DimensionMismatchException {
<span class="fc" id="L142">        this(ds1.compiler);</span>
<span class="fc" id="L143">        compiler.checkCompatibility(ds2.compiler);</span>
<span class="fc" id="L144">        compiler.linearCombination(a1, ds1.data, 0, a2, ds2.data, 0, data, 0);</span>
<span class="fc" id="L145">    }</span>

    /** Linear combination constructor.
     * The derivative structure built will be a1 * ds1 + a2 * ds2 + a3 * ds3
     * @param a1 first scale factor
     * @param ds1 first base (unscaled) derivative structure
     * @param a2 second scale factor
     * @param ds2 second base (unscaled) derivative structure
     * @param a3 third scale factor
     * @param ds3 third base (unscaled) derivative structure
     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent
     */
    public DerivativeStructure(final double a1, final DerivativeStructure ds1,
                               final double a2, final DerivativeStructure ds2,
                               final double a3, final DerivativeStructure ds3)
        throws DimensionMismatchException {
<span class="fc" id="L161">        this(ds1.compiler);</span>
<span class="fc" id="L162">        compiler.checkCompatibility(ds2.compiler);</span>
<span class="fc" id="L163">        compiler.checkCompatibility(ds3.compiler);</span>
<span class="fc" id="L164">        compiler.linearCombination(a1, ds1.data, 0, a2, ds2.data, 0, a3, ds3.data, 0, data, 0);</span>
<span class="fc" id="L165">    }</span>

    /** Linear combination constructor.
     * The derivative structure built will be a1 * ds1 + a2 * ds2 + a3 * ds3 + a4 * ds4
     * @param a1 first scale factor
     * @param ds1 first base (unscaled) derivative structure
     * @param a2 second scale factor
     * @param ds2 second base (unscaled) derivative structure
     * @param a3 third scale factor
     * @param ds3 third base (unscaled) derivative structure
     * @param a4 fourth scale factor
     * @param ds4 fourth base (unscaled) derivative structure
     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent
     */
    public DerivativeStructure(final double a1, final DerivativeStructure ds1,
                               final double a2, final DerivativeStructure ds2,
                               final double a3, final DerivativeStructure ds3,
                               final double a4, final DerivativeStructure ds4)
        throws DimensionMismatchException {
<span class="fc" id="L184">        this(ds1.compiler);</span>
<span class="fc" id="L185">        compiler.checkCompatibility(ds2.compiler);</span>
<span class="fc" id="L186">        compiler.checkCompatibility(ds3.compiler);</span>
<span class="fc" id="L187">        compiler.checkCompatibility(ds4.compiler);</span>
<span class="fc" id="L188">        compiler.linearCombination(a1, ds1.data, 0, a2, ds2.data, 0,</span>
                                   a3, ds3.data, 0, a4, ds4.data, 0,
                                   data, 0);
<span class="fc" id="L191">    }</span>

    /** Build an instance from all its derivatives.
     * @param parameters number of free parameters
     * @param order derivation order
     * @param derivatives derivatives sorted according to
     * {@link DSCompiler#getPartialDerivativeIndex(int...)}
     * @exception DimensionMismatchException if derivatives array does not match the
     * {@link DSCompiler#getSize() size} expected by the compiler
     * @throws NumberIsTooLargeException if order is too large
     * @see #getAllDerivatives()
     */
    public DerivativeStructure(final int parameters, final int order, final double ... derivatives)
        throws DimensionMismatchException, NumberIsTooLargeException {
<span class="fc" id="L205">        this(parameters, order);</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">        if (derivatives.length != data.length) {</span>
<span class="fc" id="L207">            throw new DimensionMismatchException(derivatives.length, data.length);</span>
        }
<span class="fc" id="L209">        System.arraycopy(derivatives, 0, data, 0, data.length);</span>
<span class="fc" id="L210">    }</span>

    /** Copy constructor.
     * @param ds instance to copy
     */
<span class="fc" id="L215">    private DerivativeStructure(final DerivativeStructure ds) {</span>
<span class="fc" id="L216">        this.compiler = ds.compiler;</span>
<span class="fc" id="L217">        this.data     = ds.data.clone();</span>
<span class="fc" id="L218">    }</span>

    /** Get the number of free parameters.
     * @return number of free parameters
     */
    public int getFreeParameters() {
<span class="fc" id="L224">        return compiler.getFreeParameters();</span>
    }

    /** Get the derivation order.
     * @return derivation order
     */
    public int getOrder() {
<span class="fc" id="L231">        return compiler.getOrder();</span>
    }

    /** Create a constant compatible with instance order and number of parameters.
     * &lt;p&gt;
     * This method is a convenience factory method, it simply calls
     * {@code new DerivativeStructure(getFreeParameters(), getOrder(), c)}
     * &lt;/p&gt;
     * @param c value of the constant
     * @return a constant compatible with instance order and number of parameters
     * @see #DerivativeStructure(int, int, double)
     * @since 3.3
     */
    public DerivativeStructure createConstant(final double c) {
<span class="fc" id="L245">        return new DerivativeStructure(getFreeParameters(), getOrder(), c);</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public double getReal() {
<span class="fc" id="L253">        return data[0];</span>
    }

    /** Get the value part of the derivative structure.
     * @return value part of the derivative structure
     * @see #getPartialDerivative(int...)
     */
    public double getValue() {
<span class="fc" id="L261">        return data[0];</span>
    }

    /** Get a partial derivative.
     * @param orders derivation orders with respect to each variable (if all orders are 0,
     * the value is returned)
     * @return partial derivative
     * @see #getValue()
     * @exception DimensionMismatchException if the numbers of variables does not
     * match the instance
     * @exception NumberIsTooLargeException if sum of derivation orders is larger
     * than the instance limits
     */
    public double getPartialDerivative(final int ... orders)
        throws DimensionMismatchException, NumberIsTooLargeException {
<span class="fc" id="L276">        return data[compiler.getPartialDerivativeIndex(orders)];</span>
    }

    /** Get all partial derivatives.
     * @return a fresh copy of partial derivatives, in an array sorted according to
     * {@link DSCompiler#getPartialDerivativeIndex(int...)}
     */
    public double[] getAllDerivatives() {
<span class="fc" id="L284">        return data.clone();</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure add(final double a) {
<span class="fc" id="L292">        final DerivativeStructure ds = new DerivativeStructure(this);</span>
<span class="fc" id="L293">        ds.data[0] += a;</span>
<span class="fc" id="L294">        return ds;</span>
    }

    /** {@inheritDoc}
     * @exception DimensionMismatchException if number of free parameters
     * or orders do not match
     */
    @Override
    public DerivativeStructure add(final DerivativeStructure a)
        throws DimensionMismatchException {
<span class="fc" id="L304">        compiler.checkCompatibility(a.compiler);</span>
<span class="fc" id="L305">        final DerivativeStructure ds = new DerivativeStructure(this);</span>
<span class="fc" id="L306">        compiler.add(data, 0, a.data, 0, ds.data, 0);</span>
<span class="fc" id="L307">        return ds;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure subtract(final double a) {
<span class="fc" id="L315">        return add(-a);</span>
    }

    /** {@inheritDoc}
     * @exception DimensionMismatchException if number of free parameters
     * or orders do not match
     */
    @Override
    public DerivativeStructure subtract(final DerivativeStructure a)
        throws DimensionMismatchException {
<span class="fc" id="L325">        compiler.checkCompatibility(a.compiler);</span>
<span class="fc" id="L326">        final DerivativeStructure ds = new DerivativeStructure(this);</span>
<span class="fc" id="L327">        compiler.subtract(data, 0, a.data, 0, ds.data, 0);</span>
<span class="fc" id="L328">        return ds;</span>
    }

    /** {@inheritDoc} */
    @Override
    public DerivativeStructure multiply(final int n) {
<span class="fc" id="L334">        return multiply((double) n);</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure multiply(final double a) {
<span class="fc" id="L342">        final DerivativeStructure ds = new DerivativeStructure(this);</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">        for (int i = 0; i &lt; ds.data.length; ++i) {</span>
<span class="fc" id="L344">            ds.data[i] *= a;</span>
        }
<span class="fc" id="L346">        return ds;</span>
    }

    /** {@inheritDoc}
     * @exception DimensionMismatchException if number of free parameters
     * or orders do not match
     */
    @Override
    public DerivativeStructure multiply(final DerivativeStructure a)
        throws DimensionMismatchException {
<span class="fc" id="L356">        compiler.checkCompatibility(a.compiler);</span>
<span class="fc" id="L357">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L358">        compiler.multiply(data, 0, a.data, 0, result.data, 0);</span>
<span class="fc" id="L359">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure divide(final double a) {
<span class="fc" id="L367">        final DerivativeStructure ds = new DerivativeStructure(this);</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">        for (int i = 0; i &lt; ds.data.length; ++i) {</span>
<span class="fc" id="L369">            ds.data[i] /= a;</span>
        }
<span class="fc" id="L371">        return ds;</span>
    }

    /** {@inheritDoc}
     * @exception DimensionMismatchException if number of free parameters
     * or orders do not match
     */
    @Override
    public DerivativeStructure divide(final DerivativeStructure a)
        throws DimensionMismatchException {
<span class="fc" id="L381">        compiler.checkCompatibility(a.compiler);</span>
<span class="fc" id="L382">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L383">        compiler.divide(data, 0, a.data, 0, result.data, 0);</span>
<span class="fc" id="L384">        return result;</span>
    }

    /** {@inheritDoc} */
    @Override
    public DerivativeStructure remainder(final double a) {
<span class="fc" id="L390">        final DerivativeStructure ds = new DerivativeStructure(this);</span>
<span class="fc" id="L391">        ds.data[0] = FastMath.IEEEremainder(ds.data[0], a);</span>
<span class="fc" id="L392">        return ds;</span>
    }

    /** {@inheritDoc}
     * @exception DimensionMismatchException if number of free parameters
     * or orders do not match
     * @since 3.2
     */
    @Override
    public DerivativeStructure remainder(final DerivativeStructure a)
        throws DimensionMismatchException {
<span class="fc" id="L403">        compiler.checkCompatibility(a.compiler);</span>
<span class="fc" id="L404">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L405">        compiler.remainder(data, 0, a.data, 0, result.data, 0);</span>
<span class="fc" id="L406">        return result;</span>
    }

    /** {@inheritDoc} */
    @Override
    public DerivativeStructure negate() {
<span class="fc" id="L412">        final DerivativeStructure ds = new DerivativeStructure(compiler);</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">        for (int i = 0; i &lt; ds.data.length; ++i) {</span>
<span class="fc" id="L414">            ds.data[i] = -data[i];</span>
        }
<span class="fc" id="L416">        return ds;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure abs() {
<span class="fc bfc" id="L424" title="All 2 branches covered.">        if (Double.doubleToLongBits(data[0]) &lt; 0) {</span>
            // we use the bits representation to also handle -0.0
<span class="fc" id="L426">            return negate();</span>
        } else {
<span class="fc" id="L428">            return this;</span>
        }
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure ceil() {
<span class="fc" id="L437">        return new DerivativeStructure(compiler.getFreeParameters(),</span>
<span class="fc" id="L438">                                       compiler.getOrder(),</span>
<span class="fc" id="L439">                                       FastMath.ceil(data[0]));</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure floor() {
<span class="fc" id="L447">        return new DerivativeStructure(compiler.getFreeParameters(),</span>
<span class="fc" id="L448">                                       compiler.getOrder(),</span>
<span class="fc" id="L449">                                       FastMath.floor(data[0]));</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure rint() {
<span class="fc" id="L457">        return new DerivativeStructure(compiler.getFreeParameters(),</span>
<span class="fc" id="L458">                                       compiler.getOrder(),</span>
<span class="fc" id="L459">                                       FastMath.rint(data[0]));</span>
    }

    /** {@inheritDoc} */
    @Override
    public long round() {
<span class="fc" id="L465">        return FastMath.round(data[0]);</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure signum() {
<span class="fc" id="L473">        return new DerivativeStructure(compiler.getFreeParameters(),</span>
<span class="fc" id="L474">                                       compiler.getOrder(),</span>
<span class="fc" id="L475">                                       FastMath.signum(data[0]));</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure copySign(final DerivativeStructure sign){
<span class="fc" id="L483">        long m = Double.doubleToLongBits(data[0]);</span>
<span class="fc" id="L484">        long s = Double.doubleToLongBits(sign.data[0]);</span>
<span class="fc bfc" id="L485" title="All 8 branches covered.">        if ((m &gt;= 0 &amp;&amp; s &gt;= 0) || (m &lt; 0 &amp;&amp; s &lt; 0)) { // Sign is currently OK</span>
<span class="fc" id="L486">            return this;</span>
        }
<span class="fc" id="L488">        return negate(); // flip sign</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure copySign(final double sign) {
<span class="fc" id="L496">        long m = Double.doubleToLongBits(data[0]);</span>
<span class="fc" id="L497">        long s = Double.doubleToLongBits(sign);</span>
<span class="fc bfc" id="L498" title="All 8 branches covered.">        if ((m &gt;= 0 &amp;&amp; s &gt;= 0) || (m &lt; 0 &amp;&amp; s &lt; 0)) { // Sign is currently OK</span>
<span class="fc" id="L499">            return this;</span>
        }
<span class="fc" id="L501">        return negate(); // flip sign</span>
    }

    /**
     * Return the exponent of the instance value, removing the bias.
     * &lt;p&gt;
     * For double numbers of the form 2&lt;sup&gt;x&lt;/sup&gt;, the unbiased
     * exponent is exactly x.
     * &lt;/p&gt;
     * @return exponent for instance in IEEE754 representation, without bias
     */
    public int getExponent() {
<span class="fc" id="L513">        return FastMath.getExponent(data[0]);</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure scalb(final int n) {
<span class="fc" id="L521">        final DerivativeStructure ds = new DerivativeStructure(compiler);</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">        for (int i = 0; i &lt; ds.data.length; ++i) {</span>
<span class="fc" id="L523">            ds.data[i] = FastMath.scalb(data[i], n);</span>
        }
<span class="fc" id="L525">        return ds;</span>
    }

    /** {@inheritDoc}
     * @exception DimensionMismatchException if number of free parameters
     * or orders do not match
     * @since 3.2
     */
    @Override
    public DerivativeStructure hypot(final DerivativeStructure y)
        throws DimensionMismatchException {

<span class="fc" id="L537">        compiler.checkCompatibility(y.compiler);</span>

<span class="fc bfc" id="L539" title="All 4 branches covered.">        if (Double.isInfinite(data[0]) || Double.isInfinite(y.data[0])) {</span>
<span class="fc" id="L540">            return new DerivativeStructure(compiler.getFreeParameters(),</span>
<span class="fc" id="L541">                                           compiler.getFreeParameters(),</span>
                                           Double.POSITIVE_INFINITY);
<span class="fc bfc" id="L543" title="All 4 branches covered.">        } else if (Double.isNaN(data[0]) || Double.isNaN(y.data[0])) {</span>
<span class="fc" id="L544">            return new DerivativeStructure(compiler.getFreeParameters(),</span>
<span class="fc" id="L545">                                           compiler.getFreeParameters(),</span>
                                           Double.NaN);
        } else {

<span class="fc" id="L549">            final int expX = getExponent();</span>
<span class="fc" id="L550">            final int expY = y.getExponent();</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">            if (expX &gt; expY + 27) {</span>
                // y is neglectible with respect to x
<span class="fc" id="L553">                return abs();</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">            } else if (expY &gt; expX + 27) {</span>
                // x is neglectible with respect to y
<span class="fc" id="L556">                return y.abs();</span>
            } else {

                // find an intermediate scale to avoid both overflow and underflow
<span class="fc" id="L560">                final int middleExp = (expX + expY) / 2;</span>

                // scale parameters without losing precision
<span class="fc" id="L563">                final DerivativeStructure scaledX = scalb(-middleExp);</span>
<span class="fc" id="L564">                final DerivativeStructure scaledY = y.scalb(-middleExp);</span>

                // compute scaled hypotenuse
<span class="fc" id="L567">                final DerivativeStructure scaledH =</span>
<span class="fc" id="L568">                        scaledX.multiply(scaledX).add(scaledY.multiply(scaledY)).sqrt();</span>

                // remove scaling
<span class="fc" id="L571">                return scaledH.scalb(middleExp);</span>

            }

        }
    }

    /**
     * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}
     * - sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
     * avoiding intermediate overflow or underflow.
     *
     * &lt;ul&gt;
     * &lt;li&gt; If either argument is infinite, then the result is positive infinity.&lt;/li&gt;
     * &lt;li&gt; else, if either argument is NaN then the result is NaN.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param x a value
     * @param y a value
     * @return sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
     * @exception DimensionMismatchException if number of free parameters
     * or orders do not match
     * @since 3.2
     */
    public static DerivativeStructure hypot(final DerivativeStructure x, final DerivativeStructure y)
        throws DimensionMismatchException {
<span class="fc" id="L597">        return x.hypot(y);</span>
    }

    /** Compute composition of the instance by a univariate function.
     * @param f array of value and derivatives of the function at
     * the current point (i.e. [f({@link #getValue()}),
     * f'({@link #getValue()}), f''({@link #getValue()})...]).
     * @return f(this)
     * @exception DimensionMismatchException if the number of derivatives
     * in the array is not equal to {@link #getOrder() order} + 1
     */
    public DerivativeStructure compose(final double ... f)
        throws DimensionMismatchException {
<span class="fc bfc" id="L610" title="All 2 branches covered.">        if (f.length != getOrder() + 1) {</span>
<span class="fc" id="L611">            throw new DimensionMismatchException(f.length, getOrder() + 1);</span>
        }
<span class="fc" id="L613">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L614">        compiler.compose(data, 0, f, result.data, 0);</span>
<span class="fc" id="L615">        return result;</span>
    }

    /** {@inheritDoc} */
    @Override
    public DerivativeStructure reciprocal() {
<span class="fc" id="L621">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L622">        compiler.pow(data, 0, -1, result.data, 0);</span>
<span class="fc" id="L623">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure sqrt() {
<span class="fc" id="L631">        return rootN(2);</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure cbrt() {
<span class="fc" id="L639">        return rootN(3);</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure rootN(final int n) {
<span class="fc" id="L647">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L648">        compiler.rootN(data, 0, n, result.data, 0);</span>
<span class="fc" id="L649">        return result;</span>
    }

    /** {@inheritDoc} */
    @Override
    public Field&lt;DerivativeStructure&gt; getField() {
<span class="fc" id="L655">        return new Field&lt;DerivativeStructure&gt;() {</span>

            /** {@inheritDoc} */
            @Override
            public DerivativeStructure getZero() {
<span class="fc" id="L660">                return new DerivativeStructure(compiler.getFreeParameters(), compiler.getOrder(), 0.0);</span>
            }

            /** {@inheritDoc} */
            @Override
            public DerivativeStructure getOne() {
<span class="fc" id="L666">                return new DerivativeStructure(compiler.getFreeParameters(), compiler.getOrder(), 1.0);</span>
            }

            /** {@inheritDoc} */
            @Override
            public Class&lt;? extends FieldElement&lt;DerivativeStructure&gt;&gt; getRuntimeClass() {
<span class="fc" id="L672">                return DerivativeStructure.class;</span>
            }

        };
    }

    /** Compute a&lt;sup&gt;x&lt;/sup&gt; where a is a double and x a {@link DerivativeStructure}
     * @param a number to exponentiate
     * @param x power to apply
     * @return a&lt;sup&gt;x&lt;/sup&gt;
     * @since 3.3
     */
    public static DerivativeStructure pow(final double a, final DerivativeStructure x) {
<span class="fc" id="L685">        final DerivativeStructure result = new DerivativeStructure(x.compiler);</span>
<span class="fc" id="L686">        x.compiler.pow(a, x.data, 0, result.data, 0);</span>
<span class="fc" id="L687">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure pow(final double p) {
<span class="fc" id="L695">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L696">        compiler.pow(data, 0, p, result.data, 0);</span>
<span class="fc" id="L697">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure pow(final int n) {
<span class="fc" id="L705">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L706">        compiler.pow(data, 0, n, result.data, 0);</span>
<span class="fc" id="L707">        return result;</span>
    }

    /** {@inheritDoc}
     * @exception DimensionMismatchException if number of free parameters
     * or orders do not match
     * @since 3.2
     */
    @Override
    public DerivativeStructure pow(final DerivativeStructure e)
        throws DimensionMismatchException {
<span class="fc" id="L718">        compiler.checkCompatibility(e.compiler);</span>
<span class="fc" id="L719">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L720">        compiler.pow(data, 0, e.data, 0, result.data, 0);</span>
<span class="fc" id="L721">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure exp() {
<span class="fc" id="L729">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L730">        compiler.exp(data, 0, result.data, 0);</span>
<span class="fc" id="L731">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure expm1() {
<span class="fc" id="L739">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L740">        compiler.expm1(data, 0, result.data, 0);</span>
<span class="fc" id="L741">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure log() {
<span class="fc" id="L749">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L750">        compiler.log(data, 0, result.data, 0);</span>
<span class="fc" id="L751">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure log1p() {
<span class="fc" id="L759">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L760">        compiler.log1p(data, 0, result.data, 0);</span>
<span class="fc" id="L761">        return result;</span>
    }

    /** Base 10 logarithm.
     * @return base 10 logarithm of the instance
     */
    @Override
    public DerivativeStructure log10() {
<span class="fc" id="L769">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L770">        compiler.log10(data, 0, result.data, 0);</span>
<span class="fc" id="L771">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure cos() {
<span class="fc" id="L779">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L780">        compiler.cos(data, 0, result.data, 0);</span>
<span class="fc" id="L781">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure sin() {
<span class="fc" id="L789">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L790">        compiler.sin(data, 0, result.data, 0);</span>
<span class="fc" id="L791">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure tan() {
<span class="fc" id="L799">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L800">        compiler.tan(data, 0, result.data, 0);</span>
<span class="fc" id="L801">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure acos() {
<span class="fc" id="L809">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L810">        compiler.acos(data, 0, result.data, 0);</span>
<span class="fc" id="L811">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure asin() {
<span class="fc" id="L819">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L820">        compiler.asin(data, 0, result.data, 0);</span>
<span class="fc" id="L821">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure atan() {
<span class="fc" id="L829">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L830">        compiler.atan(data, 0, result.data, 0);</span>
<span class="fc" id="L831">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure atan2(final DerivativeStructure x)
        throws DimensionMismatchException {
<span class="fc" id="L840">        compiler.checkCompatibility(x.compiler);</span>
<span class="fc" id="L841">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L842">        compiler.atan2(data, 0, x.data, 0, result.data, 0);</span>
<span class="fc" id="L843">        return result;</span>
    }

    /** Two arguments arc tangent operation.
     * @param y first argument of the arc tangent
     * @param x second argument of the arc tangent
     * @return atan2(y, x)
     * @exception DimensionMismatchException if number of free parameters
     * or orders do not match
     * @since 3.2
     */
    public static DerivativeStructure atan2(final DerivativeStructure y, final DerivativeStructure x)
        throws DimensionMismatchException {
<span class="fc" id="L856">        return y.atan2(x);</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure cosh() {
<span class="fc" id="L864">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L865">        compiler.cosh(data, 0, result.data, 0);</span>
<span class="fc" id="L866">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure sinh() {
<span class="fc" id="L874">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L875">        compiler.sinh(data, 0, result.data, 0);</span>
<span class="fc" id="L876">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure tanh() {
<span class="fc" id="L884">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L885">        compiler.tanh(data, 0, result.data, 0);</span>
<span class="fc" id="L886">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure acosh() {
<span class="fc" id="L894">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L895">        compiler.acosh(data, 0, result.data, 0);</span>
<span class="fc" id="L896">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure asinh() {
<span class="fc" id="L904">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L905">        compiler.asinh(data, 0, result.data, 0);</span>
<span class="fc" id="L906">        return result;</span>
    }

    /** {@inheritDoc}
     * @since 3.2
     */
    @Override
    public DerivativeStructure atanh() {
<span class="fc" id="L914">        final DerivativeStructure result = new DerivativeStructure(compiler);</span>
<span class="fc" id="L915">        compiler.atanh(data, 0, result.data, 0);</span>
<span class="fc" id="L916">        return result;</span>
    }

    /** Convert radians to degrees, with error of less than 0.5 ULP
     *  @return instance converted into degrees
     */
    public DerivativeStructure toDegrees() {
<span class="fc" id="L923">        final DerivativeStructure ds = new DerivativeStructure(compiler);</span>
<span class="fc bfc" id="L924" title="All 2 branches covered.">        for (int i = 0; i &lt; ds.data.length; ++i) {</span>
<span class="fc" id="L925">            ds.data[i] = FastMath.toDegrees(data[i]);</span>
        }
<span class="fc" id="L927">        return ds;</span>
    }

    /** Convert degrees to radians, with error of less than 0.5 ULP
     *  @return instance converted into radians
     */
    public DerivativeStructure toRadians() {
<span class="fc" id="L934">        final DerivativeStructure ds = new DerivativeStructure(compiler);</span>
<span class="fc bfc" id="L935" title="All 2 branches covered.">        for (int i = 0; i &lt; ds.data.length; ++i) {</span>
<span class="fc" id="L936">            ds.data[i] = FastMath.toRadians(data[i]);</span>
        }
<span class="fc" id="L938">        return ds;</span>
    }

    /** Evaluate Taylor expansion a derivative structure.
     * @param delta parameters offsets (&amp;Delta;x, &amp;Delta;y, ...)
     * @return value of the Taylor expansion at x + &amp;Delta;x, y + &amp;Delta;y, ...
     * @throws MathArithmeticException if factorials becomes too large
     */
    public double taylor(final double ... delta) throws MathArithmeticException {
<span class="fc" id="L947">        return compiler.taylor(data, 0, delta);</span>
    }

    /** {@inheritDoc}
     * @exception DimensionMismatchException if number of free parameters
     * or orders do not match
     * @since 3.2
     */
    @Override
    public DerivativeStructure linearCombination(final DerivativeStructure[] a, final DerivativeStructure[] b)
        throws DimensionMismatchException {

        // compute an accurate value, taking care of cancellations
<span class="fc" id="L960">        final double[] aDouble = new double[a.length];</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L962">            aDouble[i] = a[i].getValue();</span>
        }
<span class="fc" id="L964">        final double[] bDouble = new double[b.length];</span>
<span class="fc bfc" id="L965" title="All 2 branches covered.">        for (int i = 0; i &lt; b.length; ++i) {</span>
<span class="fc" id="L966">            bDouble[i] = b[i].getValue();</span>
        }
<span class="fc" id="L968">        final double accurateValue = MathArrays.linearCombination(aDouble, bDouble);</span>

        // compute a simple value, with all partial derivatives
<span class="fc" id="L971">        DerivativeStructure simpleValue = a[0].getField().getZero();</span>
<span class="fc bfc" id="L972" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L973">            simpleValue = simpleValue.add(a[i].multiply(b[i]));</span>
        }

        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)
<span class="fc" id="L977">        final double[] all = simpleValue.getAllDerivatives();</span>
<span class="fc" id="L978">        all[0] = accurateValue;</span>
<span class="fc" id="L979">        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), all);</span>

    }

    /** {@inheritDoc}
     * @exception DimensionMismatchException if number of free parameters
     * or orders do not match
     * @since 3.2
     */
    @Override
    public DerivativeStructure linearCombination(final double[] a, final DerivativeStructure[] b)
        throws DimensionMismatchException {

        // compute an accurate value, taking care of cancellations
<span class="fc" id="L993">        final double[] bDouble = new double[b.length];</span>
<span class="fc bfc" id="L994" title="All 2 branches covered.">        for (int i = 0; i &lt; b.length; ++i) {</span>
<span class="fc" id="L995">            bDouble[i] = b[i].getValue();</span>
        }
<span class="fc" id="L997">        final double accurateValue = MathArrays.linearCombination(a, bDouble);</span>

        // compute a simple value, with all partial derivatives
<span class="fc" id="L1000">        DerivativeStructure simpleValue = b[0].getField().getZero();</span>
<span class="fc bfc" id="L1001" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="fc" id="L1002">            simpleValue = simpleValue.add(b[i].multiply(a[i]));</span>
        }

        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)
<span class="fc" id="L1006">        final double[] all = simpleValue.getAllDerivatives();</span>
<span class="fc" id="L1007">        all[0] = accurateValue;</span>
<span class="fc" id="L1008">        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), all);</span>

    }

    /** {@inheritDoc}
     * @exception DimensionMismatchException if number of free parameters
     * or orders do not match
     * @since 3.2
     */
    @Override
    public DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,
                                                 final DerivativeStructure a2, final DerivativeStructure b2)
        throws DimensionMismatchException {

        // compute an accurate value, taking care of cancellations
<span class="fc" id="L1023">        final double accurateValue = MathArrays.linearCombination(a1.getValue(), b1.getValue(),</span>
<span class="fc" id="L1024">                                                                  a2.getValue(), b2.getValue());</span>

        // compute a simple value, with all partial derivatives
<span class="fc" id="L1027">        final DerivativeStructure simpleValue = a1.multiply(b1).add(a2.multiply(b2));</span>

        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)
<span class="fc" id="L1030">        final double[] all = simpleValue.getAllDerivatives();</span>
<span class="fc" id="L1031">        all[0] = accurateValue;</span>
<span class="fc" id="L1032">        return new DerivativeStructure(getFreeParameters(), getOrder(), all);</span>

    }

    /** {@inheritDoc}
     * @exception DimensionMismatchException if number of free parameters
     * or orders do not match
     * @since 3.2
     */
    @Override
    public DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,
                                                 final double a2, final DerivativeStructure b2)
        throws DimensionMismatchException {

        // compute an accurate value, taking care of cancellations
<span class="fc" id="L1047">        final double accurateValue = MathArrays.linearCombination(a1, b1.getValue(),</span>
<span class="fc" id="L1048">                                                                  a2, b2.getValue());</span>

        // compute a simple value, with all partial derivatives
<span class="fc" id="L1051">        final DerivativeStructure simpleValue = b1.multiply(a1).add(b2.multiply(a2));</span>

        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)
<span class="fc" id="L1054">        final double[] all = simpleValue.getAllDerivatives();</span>
<span class="fc" id="L1055">        all[0] = accurateValue;</span>
<span class="fc" id="L1056">        return new DerivativeStructure(getFreeParameters(), getOrder(), all);</span>

    }

    /** {@inheritDoc}
     * @exception DimensionMismatchException if number of free parameters
     * or orders do not match
     * @since 3.2
     */
    @Override
    public DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,
                                                 final DerivativeStructure a2, final DerivativeStructure b2,
                                                 final DerivativeStructure a3, final DerivativeStructure b3)
        throws DimensionMismatchException {

        // compute an accurate value, taking care of cancellations
<span class="fc" id="L1072">        final double accurateValue = MathArrays.linearCombination(a1.getValue(), b1.getValue(),</span>
<span class="fc" id="L1073">                                                                  a2.getValue(), b2.getValue(),</span>
<span class="fc" id="L1074">                                                                  a3.getValue(), b3.getValue());</span>

        // compute a simple value, with all partial derivatives
<span class="fc" id="L1077">        final DerivativeStructure simpleValue = a1.multiply(b1).add(a2.multiply(b2)).add(a3.multiply(b3));</span>

        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)
<span class="fc" id="L1080">        final double[] all = simpleValue.getAllDerivatives();</span>
<span class="fc" id="L1081">        all[0] = accurateValue;</span>
<span class="fc" id="L1082">        return new DerivativeStructure(getFreeParameters(), getOrder(), all);</span>

    }

    /** {@inheritDoc}
     * @exception DimensionMismatchException if number of free parameters
     * or orders do not match
     * @since 3.2
     */
    @Override
    public DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,
                                                 final double a2, final DerivativeStructure b2,
                                                 final double a3, final DerivativeStructure b3)
        throws DimensionMismatchException {

        // compute an accurate value, taking care of cancellations
<span class="fc" id="L1098">        final double accurateValue = MathArrays.linearCombination(a1, b1.getValue(),</span>
<span class="fc" id="L1099">                                                                  a2, b2.getValue(),</span>
<span class="fc" id="L1100">                                                                  a3, b3.getValue());</span>

        // compute a simple value, with all partial derivatives
<span class="fc" id="L1103">        final DerivativeStructure simpleValue = b1.multiply(a1).add(b2.multiply(a2)).add(b3.multiply(a3));</span>

        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)
<span class="fc" id="L1106">        final double[] all = simpleValue.getAllDerivatives();</span>
<span class="fc" id="L1107">        all[0] = accurateValue;</span>
<span class="fc" id="L1108">        return new DerivativeStructure(getFreeParameters(), getOrder(), all);</span>

    }

    /** {@inheritDoc}
     * @exception DimensionMismatchException if number of free parameters
     * or orders do not match
     * @since 3.2
     */
    @Override
    public DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,
                                                 final DerivativeStructure a2, final DerivativeStructure b2,
                                                 final DerivativeStructure a3, final DerivativeStructure b3,
                                                 final DerivativeStructure a4, final DerivativeStructure b4)
        throws DimensionMismatchException {

        // compute an accurate value, taking care of cancellations
<span class="fc" id="L1125">        final double accurateValue = MathArrays.linearCombination(a1.getValue(), b1.getValue(),</span>
<span class="fc" id="L1126">                                                                  a2.getValue(), b2.getValue(),</span>
<span class="fc" id="L1127">                                                                  a3.getValue(), b3.getValue(),</span>
<span class="fc" id="L1128">                                                                  a4.getValue(), b4.getValue());</span>

        // compute a simple value, with all partial derivatives
<span class="fc" id="L1131">        final DerivativeStructure simpleValue = a1.multiply(b1).add(a2.multiply(b2)).add(a3.multiply(b3)).add(a4.multiply(b4));</span>

        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)
<span class="fc" id="L1134">        final double[] all = simpleValue.getAllDerivatives();</span>
<span class="fc" id="L1135">        all[0] = accurateValue;</span>
<span class="fc" id="L1136">        return new DerivativeStructure(getFreeParameters(), getOrder(), all);</span>

    }

    /** {@inheritDoc}
     * @exception DimensionMismatchException if number of free parameters
     * or orders do not match
     * @since 3.2
     */
    @Override
    public DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,
                                                 final double a2, final DerivativeStructure b2,
                                                 final double a3, final DerivativeStructure b3,
                                                 final double a4, final DerivativeStructure b4)
        throws DimensionMismatchException {

        // compute an accurate value, taking care of cancellations
<span class="fc" id="L1153">        final double accurateValue = MathArrays.linearCombination(a1, b1.getValue(),</span>
<span class="fc" id="L1154">                                                                  a2, b2.getValue(),</span>
<span class="fc" id="L1155">                                                                  a3, b3.getValue(),</span>
<span class="fc" id="L1156">                                                                  a4, b4.getValue());</span>

        // compute a simple value, with all partial derivatives
<span class="fc" id="L1159">        final DerivativeStructure simpleValue = b1.multiply(a1).add(b2.multiply(a2)).add(b3.multiply(a3)).add(b4.multiply(a4));</span>

        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)
<span class="fc" id="L1162">        final double[] all = simpleValue.getAllDerivatives();</span>
<span class="fc" id="L1163">        all[0] = accurateValue;</span>
<span class="fc" id="L1164">        return new DerivativeStructure(getFreeParameters(), getOrder(), all);</span>

    }

    /**
     * Test for the equality of two derivative structures.
     * &lt;p&gt;
     * Derivative structures are considered equal if they have the same number
     * of free parameters, the same derivation order, and the same derivatives.
     * &lt;/p&gt;
     * @param other Object to test for equality to this
     * @return true if two derivative structures are equal
     * @since 3.2
     */
    @Override
    public boolean equals(Object other) {

<span class="fc bfc" id="L1181" title="All 2 branches covered.">        if (this == other) {</span>
<span class="fc" id="L1182">            return true;</span>
        }

<span class="fc bfc" id="L1185" title="All 2 branches covered.">        if (other instanceof DerivativeStructure) {</span>
<span class="fc" id="L1186">            final DerivativeStructure rhs = (DerivativeStructure)other;</span>
<span class="pc bpc" id="L1187" title="1 of 2 branches missed.">            return (getFreeParameters() == rhs.getFreeParameters()) &amp;&amp;</span>
<span class="pc bpc" id="L1188" title="1 of 2 branches missed.">                   (getOrder() == rhs.getOrder()) &amp;&amp;</span>
<span class="fc bfc" id="L1189" title="All 2 branches covered.">                   MathArrays.equals(data, rhs.data);</span>
        }

<span class="fc" id="L1192">        return false;</span>

    }

    /**
     * Get a hashCode for the derivative structure.
     * @return a hash code value for this object
     * @since 3.2
     */
    @Override
    public int hashCode() {
<span class="fc" id="L1203">        return 227 + 229 * getFreeParameters() + 233 * getOrder() + 239 * MathUtils.hash(data);</span>
    }

    /**
     * Replace the instance with a data transfer object for serialization.
     * @return data transfer object that will be serialized
     */
    private Object writeReplace() {
<span class="fc" id="L1211">        return new DataTransferObject(compiler.getFreeParameters(), compiler.getOrder(), data);</span>
    }

    /** Internal class used only for serialization. */
    private static class DataTransferObject implements Serializable {

        /** Serializable UID. */
        private static final long serialVersionUID = 20120730L;

        /** Number of variables.
         * @serial
         */
        private final int variables;

        /** Derivation order.
         * @serial
         */
        private final int order;

        /** Partial derivatives.
         * @serial
         */
        private final double[] data;

        /** Simple constructor.
         * @param variables number of variables
         * @param order derivation order
         * @param data partial derivatives
         */
<span class="fc" id="L1240">        DataTransferObject(final int variables, final int order, final double[] data) {</span>
<span class="fc" id="L1241">            this.variables = variables;</span>
<span class="fc" id="L1242">            this.order     = order;</span>
<span class="fc" id="L1243">            this.data      = data;</span>
<span class="fc" id="L1244">        }</span>

        /** Replace the deserialized data transfer object with a {@link DerivativeStructure}.
         * @return replacement {@link DerivativeStructure}
         */
        private Object readResolve() {
<span class="fc" id="L1250">            return new DerivativeStructure(variables, order, data);</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>